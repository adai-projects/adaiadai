@OneToOne
一对一映射映射表示一个单值关联，其中一个实体的实例与另一个实体的实例相关联。在这种类型的关联中，源实体的一个实例可以映射到目标实体的一个实例。
@OneToMany
一对多映射进入集合值关联的类别，其中实体与其他实体的集合关联。因此，在这种类型的关联中，一个实体的实例可以映射到另一个实体的任意数量的实例。
@ManyToOne
多对一映射表示实体集合可以与相似实体关联的单值关联。 因此，在关系数据库中，实体的多于一行可以引用另一个实体的相似行。
@ManyToMany


## CascadeType(级联类型)
在一切开始之前，我要先告诉大家：慎用级联关系，不要随便给all权限操作。应该根据业务需求选择所需的级联关系。否则可能酿成大祸。切记

级联持久化（保存）操作（持久保存拥有方实体时，也会持久保存该实体的所有相关数据。

给当前设置的实体操作另一个实体的权限

### CascadeType.ALL

级联所有实体状态转换

### CascadeType.PERSIST

	级联实体持久化操作

	指定cascade = CascadeType.PERSIST在实体类关联的实体字段上，那么保存该实体类时会级联保存该实体类关联的实体。

### CascadeType.MERGE

	级联实体合并操作

	在合并期间，获取子实体Phone时，会连同获取级联的父实体Person。这个级联只能合并数据库已存在的实体。
		对象会进入到被管理状态，对该对象（可以是任何状态的对象）的操作会自动同步到数据库。

	当Student中的数据改变，会相应地更新Course中的数据。

### CascadeType.REMOVE

	级联实体删除操作

	CascadeType.REMOVE使我们能够沿父实体一个删除级联的子实体。

	级联删除操作，删除当前实体时，与它有映射关系的实体也会跟着被删除。

### CascadeType.REFRESH

	级联实体刷新操作

	当对父实体Person级联的对象进行操作并保存时，会关联保存子实体Phone到数据库。

	级联刷新操作

	假设场景 有一个订单,订单里面关联了许多商品,这个订单可以被很多人操作,那么这个时候A对此订单和关联的商品进行了修改,与此同时,B也进行了相同的操作,但是B先一步比A保存了数据,那么当A保存数据的时候,就需要先刷新订单信息及关联的商品信息后,再将订单及商品保存。

### CascadeType.DETACH

	级联实体分离操作

	意思是，分离所有相关联的实体，该实体已在数据库中，对象将处于分离状态，对该对象的操作不会同步到数据库。

	级联脱管/游离操作。

	如果你要删除一个实体，但是它有外键无法删除，你就需要这个级联权限了。它会撤销所有相关的外键关联。
===================================================================================================================
FetchType.LAZY：
	懒加载，加载一个实体时，定义懒加载的属性不会马上从数据库中加载

FetchType.EAGER：
	急加载，加载一个实体时，定义急加载的属性会立即从数据库中加载


按照大家学习SpringBoot的经验来看, SpringBoot的@GeneratedValue 是不需要加参数的,但是如果数据库控制主键自增(auto_increment), 不加参数就会报错.
(血的教训, 看了@GeneratedValue源代码才知道)
@GeneratedValue(strategy=GenerationType.IDENINY)
PS:@GeneratedValue注解的strategy属性提供四种值:
-AUTO主键由程序控制, 是默认选项 ,不设置就是这个
-IDENTITY 主键由数据库生成, 采用数据库自增长, Oracle不支持这种方式
-SEQUENCE 通过数据库的序列产生主键, MYSQL  不支持
-Table 提供特定的数据库产生主键, 该方式更有利于数据库的移植

---------------------
