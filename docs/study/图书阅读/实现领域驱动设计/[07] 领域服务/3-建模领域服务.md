建模领域服务
======================================================
> 根据创建领域服务的目的，有时对领域服务进行建模是非常简单的。


你需要决定你所创建的领域服务是否需要一个独立接口[Fowler, P of EAA]。
该接口和那些与身份相关的聚合定义在相同的模块中。
对于借口的实现类，我们可以选择性地放在不同的地方。如果你使用依赖倒置原则或六边形架构，
那么你可能会将多少有些技术性的实现类放置在领域模型之外。
比如，技术实现类可以放置在基础设施层的某个模块中。

## 独立接口有必要吗

  如果有确定的实现过程，不会再有不用的处理方案时，确实不需要独立的借口。
  假如，一个身份认证，不同的租户可能有不同的安全认证标准，所以产生不同的认证实现类也是有可能的。

### 给领域服务的实现类命名

  在Java世界中，常见的命名实现类的方法便是给接口名加上Impl后缀。实现类和借口通常被放在相同的包下。
  事实上，如果你采用这种方式来命名实现类，这往往意味着你根本就不需要一个独立的接口。

  如果领域服务具有多个实现类，那么应该根据各种实现类的特点进行命名，而这又往往意味着在你的领域服务中存在一些特定的行为功能。

  举例，可以将接口EncryptionService放在领域模型中，而将MD5EncryptionService放在基础设施层中。

  对于非技术性的领域服务来说，去除独立接口是不会破坏可测试性的，
  因为这些领域服务所依赖的所有接口都可以注入进来，或者通过服务工厂进行创建。

  请记住，非技术性的领域服务都必须进行正确性测试。

  有时，领域服务总是和领域密切相关，并且不会有技术性的实现，或者不会有多个实现，此时采用独立接口便是一个风格上的问题。
  [Fowler, P of EAA]中说，独立接口对于解耦来说是有用处的，此时客户端需要依赖借口，而不需要知道具体的实现。
  但是，如果我们使用依赖注入或者工厂，即便接口和实现类是合并在一起的，我们一栏能达到这样的目的。

  依赖倒置容器（比如Spring）将完成服务实例的注入工作。
  由于客户端并不负责服务的实例化，它并不知道该接口类和实现类是分开的还是合并在一起的。

  与服务工厂和依赖注入相比，有时更倾向于将领域服务作为构造函数参数或方法参数注入，
  因为这样的代码拥有很好的可测试性，甚至比依赖注入更加简单。
  也有人根据实际情况同时采用以上三种方式，并且优先采用基于构造函数的注入方式。

## 一个计算过程

- 绝对不能将业务逻辑放在应用层中
- 虽然我们不会将业务逻辑放在应用层，但是应用层却可以作为领域服务的客户端。

## 转换服务

  在基础设施层中，更加技术性的领域服务通常都是那些用于集成目的的服务。
  参考，集成限界上下文中领域服务接口、实现类、适配器和不同的转换器。

## 为领域服务创建一个迷你层

  ？ package，···.domain.model.product.services

  有时我们可能希望在实体和值对象之上创建一个领域服务的迷你层，这样做可能会导致贫血领域服务这种反模式。
  但是，对于有些系统来说，为领域服务创建一个不至于导致贫血领域模型的迷你层是值得的。
  当然，这取决于领域模型的特征。
